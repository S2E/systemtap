/* This tapset contains only leaf/embedded-c functions so as to avoid
 pulling in unnecessary larger pass-2 computations. */


/* When a syscall interjection mechanism gives us a pt_regs*
   structure for the syscall parameters/context, we can pretend
   as though it were a user-space probe. */
function __set_usermode_pt_regs(r)
%{
  c->uregs = (void*)STAP_ARG_r;
  c->user_mode_p = 1;
%}


function _stp_syscall_nr:long ()
%{ /* pure */
	struct pt_regs *regs = _stp_current_pt_regs();
	if (!regs) {
		CONTEXT->last_error = ("Cannot access syscall number"
				       " (no registers available)");
		return;
	}
	STAP_RETVALUE = _stp_syscall_get_nr(current, regs);
%}

